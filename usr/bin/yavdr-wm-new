#!/usr/bin/env python

import wnck
import gtk
import optparse
#import pyatspi
import syslog
### new imports ###
import dbus
import uinput
import socket
import string
import gobject
###################
import ConfigParser
import os

class WindowsManagerConfig:

    def __init__(self):
        self.config = ConfigParser.ConfigParser()
        self.config.read(['/etc/yavdr-desktop/yavdr-wm.conf', os.path.expanduser('~/.yavdr-wm.conf')])
        self.config = dict(self.getConfigSections())

    def getConfigOptions(self, section):
        for option in self.config.options(section):
            yield option, self.config.get(section, option)

    def getConfigSections(self):
        for section in self.config.sections():
            yield section, dict(self.getConfigOptions(section))


class WindowsManager(object):
    def __init__(self, title_matches=None):
        if title_matches is None:
            title_matches = ["softhddevice", "XBMC Media Center", "xbmc.bin"]
        self.title_matches = [s.lower() for s in title_matches]
        
        self.remote = self.create_dbus_remoteHandler()
        Lircd2Any = lircd2any('/var/run/lirc/lircd', None)
               
        screen = wnck.screen_get_default()
        screen.connect("active-window-changed", self.on_active_window_changed)
        screen.connect("window-opened", self.on_window_opened)
    
    def match_window(self, window):
        window_title = window.get_name().lower()
        return any(s in window_title for s in self.title_matches)
    
    def match_application(self, application):
        application_title = application.get_name().lower()
        return any(s in application_title for s in self.title_matches)
    
    def undecorate_and_maximize(self, window):
        syslog.syslog("undecorate window: " + window.get_name())
        xwindow = gtk.gdk.window_foreign_new(window.get_xid())
        xwindow.set_decorations(0)
        window.maximize()

    def on_active_window_changed (self, screen, previous):
        active = screen.get_active_window()
        syslog.syslog("window " + active.get_name() + " got active")
        if active and active is not None:
            if self.match_window(active) or self.match_application(active.get_application()):
                self.undecorate_and_maximize(active)

    def on_window_opened (self, screen, window):
        syslog.syslog("window " + window.get_name() + " was opened")
        if self.match_window(window) or self.match_application(window.get_application()):
            self.undecorate_and_maximize(window)

    '''def pressKey(self, keycode):
        """Takes an integer keycode. You can find these with xev."""
        pyatspi.Registry.generateKeyboardEvent(keycode, None,
                                              pyatspi.KEY_PRESSRELEASE)'''
                                              
    def create_dbus_remoteHandler(self):
        '''Create dbus handler for vdr dbus remote'''
        bus = dbus.SystemBus()
        proxy_obj = bus.get_object("de.tvdr.vdr", "/Remote")
        remote = dbus.Interface(proxy_obj, "de.tvdr.vdr.remote")
        return remote
    
    ''' Example functions to control if VDR reacts to remote events
    def remote_status(self):
        # get current remote status
        return self.remote.Status()
    
    def disableRemote(self):
        self.remote.Disable()
        
    def enableRemode(self):
        self.remote.Enable()
    '''
        
class lircd2any():

    def __init__(self,socket_path, activeout):
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)   
        self.sock.connect(socket_path)
        self.OutputDevs = {}
        self.add_output_device()
        self.add_output_device('lirc','lirc',socket_path='/var/run/lirc/bridge')
        self.active_output = None
        self.set_active_output(activeout)
        syslog.syslog("Listening to %s..." %(socket_path))
        gobject.io_add_watch(self.sock, gobject.IO_IN, self.handler)

    def handler(self, sock, *args):
        '''Asynchronous connection handler. Processes each line from the socket.'''
        buf = sock.recv(1024)
        lines = string.split(buf, "\n")
        for line in lines[:-1]:
          code,count,cmd,device = string.split(line, " ")
          self.output(code, count, cmd, device)
          return True

    def output(self, code, count, cmd, device):
        #print " ".join([code, count, cmd, device])
        if self.active_output != None:
            self.active_output.send_key(code, count, cmd, device)

    def set_active_output(self, device):
        if device == 'None' or device == None:
            self.active_output = None

        else:
            try:
                self.active_output = self.OutputDevs[device]
            except:
                syslog.syslog('No matching device for %s found, setting to None' %(device))
                self.active_output = None

    def add_output_device(self, devicename='uinput', devicetype='uinput', match=['KEY_'], socket_path='/var/run/lirc/bridge'):
        self.OutputDevs[devicename] = OutputDev(devicename,devicetype,match,socket_path)


class OutputDev():
  
    def __init__(self, devicename='uinput',devicetype='uinput',match=['KEY_','BTN_','REL_'],socket_path='/var/run/lirc/bridge'):    
        self.devicetype = devicetype    
        if devicetype == 'uinput':
            self.events = self.select_capabilities(match)
            self.device = uinput.Device(self.events, devicename)
        if devicetype == 'lirc':
            self.device, self.conn = self.create_lircd_socket(socket_path)

    def select_capabilities(self,match):
        keys = []
        items = dir(uinput)
        for item in itertools.product(match,items):
            if item[1].startswith(item[0]):
                keys.append(eval('uinput.%s'%(item[1])))
        return keys

    def create_lircd_socket(self, socket_path):
        try:
            os.remove(socket_path)
        except OSError:
            pass
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(socket_path)
        sock.listen(1)
        conn, addr = sock.accept()
        return sock, conn

    def send_key(self, code, count, cmd, device):
        if self.devicetype == 'uinput':
            self.device.emit(eval('uinput.%s'%(cmd)),1)
            self.device.emit(eval('uinput.%s'%(cmd)),0)
        if self.devicetype == 'lirc':
            self.conn.send("%s\n"%" ".join([code, count, cmd, device]))



def getOptions():          
    parser = optparse.OptionParser()

    parser.add_option('-t', '--title', metavar='TITLE', action='append',
        dest='title_matches', help='Match window title')
    
    options, args = parser.parse_args()
    return options,args

def main():
    options, args = getOptions()
    wmc = WindowsManagerConfig()
    wm = WindowsManager(title_matches=options.title_matches)
    
	# This is a standard GTK mechanism, which is required to capture all existing events
    while gtk.events_pending():   
        gtk.main_iteration()
        
    gtk.main()

if __name__ == '__main__':
    main()
